---
title: 索引
categories: 
- MySQL
---

**原文：** https://juejin.cn/post/6858437057196261389

**首先了解下InnoDB是如何存储数据的** MySQL 把数据存储和查询操作抽象成了存储引擎，不同的存储引擎，对数据的存储和读取 方式各不相同。

同时MySQL 支持多种存储引擎，并且可以以表为粒度设置存储引擎。因为支持 事务，我们最常使用的是 InnoDB。

**为方便理解下面的内容，我先和你简单说说 InnoDB 是 如何存储数据的。**

虽然数据保存在磁盘中，但其处理是在内存中进行的。为了减少磁盘随机读取次数， InnoDB 采用页而不是行的粒度来保存数据，即数据被分成若干页，以页为单位保存在磁盘 中。InnoDB 的页大小，一般是 16KB。

各个数据页组成一个双向链表，`每个数据页中的记录按照主键顺序组成单向链表；`每一个数 据页中有一个页目录，方便按照主键查询记录。

# 聚簇索引和二级索引

说到索引，页目录就是最简单的索引，是通过对记录进行一级分组来降低搜索的时间复杂 度。但，这样能够降低的时间复杂度数量级，非常有限。当有无数个数据页来存储表数据的 时候，我们就需要考虑如何建立合适的索引，才能方便定位记录所在的页。

**为了解决这个问题，InnoDB 引入了 B+ 树。** 数据结构特点:

- 最底层的节点叫作叶子节点，用来存放数据；
- 其他上层节点叫作非叶子节点，仅用来存放目录项，作为索引；
- 非叶子节点分为不同层次，通过分层来降低每一层的搜索量；
- 所有节点按照索引键大小排序，构成一个双向链表，加速范围查找。

因此，InnoDB 使用 B+ 树，既可以保存实际数据，也可以加速数据搜索，这就是聚簇索 引。

InnoDB 会自动使用主键（唯一定义一条记录的单个或多个字段）作为聚簇索引的索引键 （如果没有主键，就选择第一个不包含 NULL 值的唯一列）。

**我们再看看 B+ 树如何实现快速查找主键。** 比如，我们要搜索 主键id=4 的数据，通过根节点 中的索引可以知道数据在第一个记录指向的 2 号页中，通过 2 号页的索引又可以知道数据 在 5 号页，5 号页就是实际的数据页，然后再通过二分法查找页目录马上可以找到记录的 指针。

为了实现非主键字段的快速搜索，就引出了二级索引，也叫作非聚簇索引、辅助索引。二级 索引，也是利用的 B+ 树的数据结构

这次二级索引的叶子节点中保存的不是实际数据，而是主键，获得主键值后去聚簇索引中获 得数据行。这个过程就叫作`回表。`

举个例子，有个索引是针对用户名字段创建的，索引记录上面方块中的字母是用户名，按照 顺序形成链表。如果我们要搜索用户名为 b 的数据，经过两次定位可以得出在 #5 数据页 中，查出所有的主键为 7 和 6，再拿着这两个主键继续使用聚簇索引进行两次回表得到完 整数据

# 创建二级索引的代价

创建二级索引的代价，主要表现在维护代价、空间代价和回表代价三个方面。接下来，我就 与你仔细分析下吧。

首先是维护代价。创建 N 个二级索引，就需要再创建 N 棵 B+ 树，新增数据时不仅要修改 聚簇索引，还需要修改这 N 个二级索引。

我们通过实验测试一下创建索引的代价。假设有一个 person 表，有主键 ID，以及 name、score、create_time 三个字段：

```sql
create TABLE `person` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `score` int(11) NOT NULL,
  `create_time` timestamp NOT NULL,
  PRIMARY KEY (`id`),
  KEY `name_score` (`name`,`score`) USING BTREE,
  KEY `create_time` (`create_time`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

通过下面的存储过程循环创建 10 万条测试数据，我的机器的耗时是 140 秒（本文的例子 均在 MySQL 5.7.26 中执行）：

```sql
create DEFINER=`root`@`%` PROCEDURE `insert_person`()
begin
    declare c_id integer default 1;
    while c_id<=100000 do
    insert into person values(c_id, concat('name',c_id), c_id+100, date_sub(NOW(), interval c_id second));
    set c_id=c_id+1;
    end while;
end
```

如果再创建两个索引，一个是 name 和 score 构成的联合索引，另一个是单一列 create_time 的索引，那么创建 10 万条记录的耗时提高到 154 秒

```sql
KEY `name_score` (`name`,`score`) USING BTREE, 
KEY `create_time` (`create_time`) USING BTREE
```

这里，我再额外提一下，页中的记录都是按照索引值从小到大的顺序存放的，新增记录就需 要往页中插入数据，现有的页满了就需要新创建一个页，把现有页的部分数据移过去，这就 是页分裂；如果删除了许多数据使得页比较空闲，还需要进行页合并。页分裂和合并，都会 有 IO 代价，并且可能在操作过程中产生死锁。

`可以查看文档，以进一步了解如何设置合理的合并阈值，来平衡页的空闲率和因 为再次页分裂产生的代价。`其次是空间代价。虽然二级索引不保存原始数据，但要保存索引列的数据，所以会占用更多 的空间。比如，person 表创建了两个索引后，使用下面的 SQL 查看数据和索引占用的磁 盘：

```sql
select DATA_LENGTH, INDEX_LENGTH from information_schema.TABLES where TABLE_NAME='person';
```

结果显示，数据本身只占用了 4.7M，而索引占用了 8.4M。

最后是回表的代价。二级索引不保存原始数据，通过索引找到主键后需要再查询聚簇索引， 才能得到我们要的数据。比如，使用 SELECT * 按照 name 字段查询用户，使用 EXPLAIN 查看执行计划

```sql
EXPLAIN SELECT * FROM person WHERE NAME='name1'
```

key 字段代表实际走的是哪个索引，其值是 name_score，说明走的是 name_score 这 个索引。 type 字段代表了访问表的方式，其值 ref 说明是二级索引等值匹配，符合我们的查询。

把 SQL 中的 * 修改为 NAME 和 SCORE，也就是 SELECT name_score 联合索引包含的两 列：

```sql
EXPLAIN SELECT NAME,SCORE FROM person WHERE NAME='name1'
```

可以看到，Extra 列多了一行 Using index 的提示，证明这次查询直接查的是二级索引，免 去了回表。

如果我们需要查询的是索引列索引或联合索引能覆盖的数据，那么查询索引本身已 经“覆盖”了需要的数据，不再需要回表查询。因此，这种情况也叫作索引覆盖。

**最后，我和你总结下关于索引开销的最佳实践吧。 ** 第一，无需一开始就建立索引，可以等到业务场景明确后，或者是数据量超过 1 万、查询 变慢后，再针对需要查询、排序或分组的字段创建索引。创建索引后可以使用 EXPLAIN 命 令，确认查询是否可以使用索引。

第二，尽量索引轻量级的字段，比如能索引 int 字段就不要索引 varchar 字段。索引字段也 可以是部分前缀，在创建的时候指定字段索引长度。针对长文本的搜索，可以考虑使用 Elasticsearch 等专门用于文本搜索的索引数据库。

第三，尽量不要在 SQL 语句中 SELECT *，而是 SELECT 必要的字段，甚至可以考虑使用联 合索引来包含我们要搜索的字段，既能实现索引加速，又可以避免回表的开销。

**不是所有针对索引列的查询都能用上索引** 在上一个案例中，我创建了一个 name+score 的联合索引，仅搜索 name 时就能够用上这 个联合索引。这就引出两个问题：

```
是不是建了索引一定可以用上？怎么选择创建联合索引还是多个独立索引？
```

首先，我们通过几个案例来分析一下索引失效的情况。 第一，索引只能匹配列前缀。比如下面的 LIKE 语句，搜索 name 后缀为 name123 的用户 无法走索引，执行计划的 type=ALL 代表了全表扫描：

```sql
EXPLAIN SELECT * FROM person WHERE NAME LIKE '%name123' LIMIT 100
```

把百分号放到后面走前缀匹配，type=range 表示走索引扫描，key=name_score 看到实 际走了 name_score 索引 原因很简单，索引 B+ 树中行数据按照索引值排序，只能根据前缀进行比较。如果要按照后 缀搜索也希望走索引的话，并且永远只是按照后缀搜索的话，可以把数据反过来存，用的时 候再倒过来

第二，条件涉及函数操作无法走索引。比如搜索条件用到了 LENGTH 函数，肯定无法走索 引： 同样的原因，索引保存的是索引列的原始值，而不是经过函数计算后的值。如果需要针对函 数调用走数据库索引的话，只能保存一份函数变换后的值，然后重新针对这个计算列做索 引。

第三，联合索引只能匹配左边的列。也就是说，虽然对 name 和 score 建了联合索引，但 是仅按照 score 列搜索无法走索引 原因也很简单，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会 按照第二列排序。也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个 列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索 引。尝试把搜索条件加入 name 列，可以看到走了 name_score 索引 需要注意的是，因为有查询优化器，所以 name 作为 WHERE 子句的第几个条件并不是很 重要。

# 数据库基于成本决定是否走索引

通过前面的案例，我们可以看到，查询数据可以直接在聚簇索引上进行全表扫描，也可以走 二级索引扫描后到聚簇索引回表。看到这里，你不禁要问了，MySQL 到底是怎么确定走哪 种方案的呢。

其实，MySQL 在查询数据之前，会先对可能的方案做执行计划，然后依据成本决定走哪个 执行计划。

**这里的成本，包括 IO 成本和 CPU 成本：** IO 成本，是从磁盘把数据加载到内存的成本。默认情况下，读取数据页的 IO 成本常数 是 1（也就是读取 1 个页成本是 1）。

CPU 成本，是检测数据是否满足条件和排序等 CPU 操作的成本。默认情况下，检测记 录的成本是 0.2。 基于此，我们分析下全表扫描的成本。

全表扫描，就是把聚簇索引中的记录依次和给定的搜索条件做比较，把符合搜索条件的记录 加入结果集的过程。那么，要计算全表扫描的代价需要两个信息：

- 聚簇索引占用的页面数，用来计算读取数据的 IO 成本；
- 表中的记录数，用来计算搜索的 CPU 成本。

**我们可以得到两个结论：** MySQL 选择索引，并不是按照 WHERE 条件中列的顺序进行的； 即便列有索引，甚至有多个可能的索引方案，MySQL 也可能不走索引。

其原因就是，MySQL 并不是猜拳决定是否走索引的，而是根据成本来判断的。虽然表的统 计信息不完全准确，但足够用于策略的判断了。 不过，有时会因为统计信息的不准确或成本估算的问题，实际开销会和 MySQL 统计出来 的差距较大，导致 MySQL 选择错误的索引或是直接选择走全表扫描，这个时候就需要人 工干预，使用强制索引了。比如，像这样强制走 name_score 索引：

```sql
explain select * from person force inndex(name_score) where NAME >'name84059' and create_time>'2020-01-24 05:00:00';
```

我们介绍了 MySQL 会根据成本选择执行计划，也通过 EXPLAIN 知道了优化器最终会选择 怎样的执行计划，但 MySQL 如何制定执行计划始终是一个黑盒。

**那么，有没有什么办法 可以了解各种执行计划的成本，以及 MySQL 做出选择的依据呢？**

在 MySQL 5.6 及之后的版本中，我们可以使用 optimizer trace 功能查看优化器生成执行 计划的整个过程。有了这个功能，我们不仅可以了解优化器的选择过程，更可以了解每一个 执行环节的成本，然后依靠这些信息进一步优化查询。

如下代码所示，打开 optimizer_trace 后，再执行 SQL 就可以查询 information_schema.OPTIMIZER_TRACE 表查看执行计划了，最后可以关闭 optimizer_trace 功能：

```sql
SET optimizer_trace="enabled=on";
explain select * from person where NAME >'name84059' and create_time>'2020-01-24 05:00:00';
select * from information_schema.OPTIMIZER_TRACE;
SET optimizer_trace="enabled=off";
```

公众号，欢迎关注 ！！！

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b676f95322f483f96f7f3f4c5928bc3~tplv-k3u1fbpfcp-zoom-1.image)