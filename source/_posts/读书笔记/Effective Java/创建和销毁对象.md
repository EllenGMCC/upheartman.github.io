---
title: 创建和销毁对象
categories: 
- 读书笔记
- Effective Java
---

**用静态工厂方法代替构造器**

对于类而言，为了让客户端获取它自身的一个实例，最传统的方法就是提供一个公有的构造器

还有一种方法，类可以提供一个公有的静态工厂方法，它只是一个返回类的实例的静态方法

下面是一个来自Boolean的简单示例

这个方法将boolean 基本类型值转换成了一个Boolean 对象引用：

```java
public static final Boolean TRUE = new Boolean(true);
public static final Boolean FALSE = new Boolean(false);

public static Boolean valueOf(boolean b) {
	return  b? Boolean.TRUE : Boolean.FALSE;
}
```

> 优势

1. 它们有名称，代码也更易于阅读
2. 不必再每次调用它们的时候都创建一个新对象，可极大地提升性能
3. 它们可以返回原返回类型的任何子类型的对象，有了更大的灵活性
4. 返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值
5. 方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在

> 缺点

1. 类如果不含公有的或者受保护的构造器，就不能被子类化
2. 程序员很难发现它们，API文档没有明确标识出来

> 总结

简而言之，静态工厂方法和公有构造器都各有用处，我们需要理解它们各自的长处，静态工厂经常更加合适，因此切忌第一反应就是提供公有的构造器，而不先考虑静态工厂

**遇到多个构造器参数时要考虑使用构建器**

静态工厂和构造器有个共同的局限性：它们都不能很好地扩展到大量的可选参数

> 方式一：重叠构造器模式

程序员一向习惯采用**重叠构造器模式**，在这种模式下，提供的第一个构造器只有必要的参数，第二个构造器有一个可选参数，第三个构造器有两个可选参数，以此类推，最后一个构造器包含所有可选的参数

```java
/**
 * 描述：重叠构造器
 */
public class NutritionFactsConstructor {

    private final int servingSize;   // required
    private final int servings;      // required
    private final int calories;      // optional
    private final int fat;           // optional
    private final int sodium;        // optional
    private final int carbohydrate;  // optional

    public NutritionFactsConstructor(int servingSize, int servings){
        this(servingSize, servings, 0);
    }
    public NutritionFactsConstructor(int servingSize, int servings, int calories){
        this(servingSize, servings, calories, 0);
    }
    public NutritionFactsConstructor(int servingSize, int servings, int calories, int fat){
        this(servingSize, servings, calories, fat, 0);
    }
    public NutritionFactsConstructor(int servingSize, int servings, int calories, int fat, int sodium){
        this(servingSize, servings, calories, fat, sodium, 0);
    }
    public NutritionFactsConstructor(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate){
        this.servingSize = servingSize;
        this.servings = servings;
        this.calories = calories;
        this.fat = fat;
        this.sodium = sodium;
        this.carbohydrate = carbohydrate;
    }

    @Override
    public String toString() {
        return "NutritionFactsConstructor{" +
                "servingSize=" + servingSize +
                ", servings=" + servings +
                ", calories=" + calories +
                ", fat=" + fat +
                ", sodium=" + sodium +
                ", carbohydrate=" + carbohydrate +
                '}';
    }

    public static void main(String[] args) {
        NutritionFactsConstructor n1 = new NutritionFactsConstructor(1, 2);
        NutritionFactsConstructor n2 = new NutritionFactsConstructor(1, 2 ,3);
        NutritionFactsConstructor n3 = new NutritionFactsConstructor(1, 2, 0 , 4);

        System.out.println("n1 = " + n1);
        System.out.println("n2 = " + n2);
        System.out.println("n3 = " + n3);
    }
}
```

简而言之，重叠构造器模式可行，但是当有许多参数的时候，客户端代码会很难缩写，并且仍然较难以阅读

如果客户端不小心颠倒了其中两个参数的顺序，编译器也不会出错，但是程序在运行时会出现错误的行为

> 方式二：JavaBeans模式

在这种模式下，先调用一个无参构造器来创建对象，然后再调用 setter 方法来设置每个必要的参数，以及每个相关的可选参数

```java
/**
 * 描述：JavaBeans 模式
 */
public class NutritionFactsJavaBeans {

    private int servingSize = -1;  // Required; no default value
    private int servings = -1;     // Required; no default value
    private int calories = 0;
    private int fat = 0;
    private int sodium = 0;
    private int carbohydrate = 0;

    public NutritionFactsJavaBeans() {
    }

    public void setServingSize(int servingSize) {
        this.servingSize = servingSize;
    }

    public void setServings(int servings) {
        this.servings = servings;
    }

    public void setCalories(int calories) {
        this.calories = calories;
    }

    public void setFat(int fat) {
        this.fat = fat;
    }

    public void setSodium(int sodium) {
        this.sodium = sodium;
    }

    public void setCarbohydrate(int carbohydrate) {
        this.carbohydrate = carbohydrate;
    }

    @Override
    public String toString() {
        return "NutritionFactsJavaBeans{" +
                "servingSize=" + servingSize +
                ", servings=" + servings +
                ", calories=" + calories +
                ", fat=" + fat +
                ", sodium=" + sodium +
                ", carbohydrate=" + carbohydrate +
                '}';
    }

    public static void main(String[] args) {
        NutritionFactsJavaBeans n = new NutritionFactsJavaBeans();
        n.setServingSize(240);
        n.setServings(8);
        n.setCalories(100);
        n.setSodium(35);
        n.setCarbohydrate(27);

        System.out.println("n = " + n);
    }
}
```

因为构造过程被分到了几个调用中，**在构造过程中 Java Bean 可能处于不一致的状态** 

类无法仅仅通过检验构造器参数的有效性来保证一致性，试图使用处于不一致状态的对象将会导致失败，这种失败与包含错误的代码大相径庭，因此调试起来十分困难

与此相关的另一点不足在于， **Java Beans 模式使得把类做成不可变的可能性不复存在** ，这就需要程序员付出额外的努力来确保的线程安全

> 方式三：建造者（Build）模式

它不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器（或者静态工厂），得到一个 builder 对象

然后客户端在 bulder 对象上调用类 setter 的方法，来设置每个相关的可选参数 最后，客户端调用无参的 build 方法来生成通常是不可变的对象，这个 builder 通常是它构建的类的静态成员类

```java
/**
 * 描述：Builder 模式
 */
public class NutritionFactsBuilder {

    private final int servingSize;   // required
    private final int servings;      // required
    private final int calories;      // optional
    private final int fat;           // optional
    private final int sodium;        // optional
    private final int carbohydrate;  // optional

    private NutritionFactsBuilder(Builder builder) {
        servingSize = builder.servingSize;
        servings = builder.servings;
        calories = builder.calories;
        fat = builder.fat;
        sodium = builder.sodium;
        carbohydrate = builder.carbohydrate;
    }

    @Override
    public String toString() {
        return "NutritionFactsBuilder{" +
                "servingSize=" + servingSize +
                ", servings=" + servings +
                ", calories=" + calories +
                ", fat=" + fat +
                ", sodium=" + sodium +
                ", carbohydrate=" + carbohydrate +
                '}';
    }

    public static class Builder {
        // required
        private final int servingSize;
        private final int servings;

        // optional
        private int calories = 0;
        private int fat = 0;
        private int sodium = 0;
        private int carbohydrate = 0;

        public NutritionFactsBuilder build() {
            return new NutritionFactsBuilder(this);
        }

        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings = servings;
        }

        public Builder calories(int value) {
            this.calories = value;
            return this;
        }

        public Builder fat(int value) {
            this.fat = fat;
            return this;
        }

        public Builder sodium(int value) {
            this.sodium = value;
            return this;
        }

        public Builder carbohydrate(int value) {
            this.carbohydrate = value;
            return this;
        }
    }

    public static void main(String[] args) {
        NutritionFactsBuilder n = new NutritionFactsBuilder.Builder(240, 8)
                .calories(100)
                .sodium(35)
                .carbohydrate(27)
                .build();

        System.out.println("n = " + n);
    }
}
```

Builder模式的确也有它自身的不足

为了创建对象，必须先创建它的构建器，虽然创建这个构建器的开销在实践中可能不那么明显，但是在某些十分注重性能的情况下，可能就成问题了

**如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式就是一种不错的选择**，特别是当大多数参数都是可选或者类型相同的时候