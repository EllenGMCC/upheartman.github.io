---
title: 单个键管理
categories: 
- 读书笔记
- Redis开发与运维
- 键管理
---

# 单个键

**键重命名：rename key newkey**

将键python重命名为java：

```
127.0.0.1:6379> set python jedis
OK
127.0.0.1:6379> rename python java
OK
127.0.0.1:6379> get python
(nil)
127.0.0.1:6379> get java
"jedis"
```

如果在rename之前，键java已经存在，那么它的值也将被覆盖

为了防止被强行rename，Redis提供了renamenx命令，确保只有newKey不存在时候才被覆盖

例如下面操作renamenx时，newkey=python已经存在，返回结果是0代表没有完成重命名，所以键java和python的值没变：

```
127.0.0.1:6379> set java jedis
OK
127.0.0.1:6379> set python redis-py
OK
127.0.0.1:6379> renamenx java python
(integer) 0
127.0.0.1:6379> get java
"jedis"
127.0.0.1:6379> get python
"redis-py"
```

**重命名命令有两点需要注意：**

* 由于重命名键期间会执行del命令删除旧的键，如果键对应的值比较大，会存在阻塞Redis的可能性

* 如果rename和renamenx中的key和newkey如果是相同的，在Redis3.2和之前版本返回结果略有不同

Redis3.2中会返回OK

Redis3.2之前的版本会提示错误：

```
127.0.0.1:6379> rename key key
(error) ERR source and destination objects are the same
```

**随机返回一个键：randomkey**

下面示例中，当前数据库有1000个键值对，randomkey命令会随机从中挑选一个键：

```
127.0.0.1:6379> dbsize
1000
127.0.0.1:6379> randomkey
"hello"
127.0.0.1:6379> randomkey
"jedis"
```

# 键过期

```
expire key seconds
```

键在seconds秒后过期

下面为键hello设置了10秒的过期时间，然后通过ttl观察它的过期剩余时间（单位：秒），随着时间的推移，ttl逐渐变小，最终变为-2：

```
127.0.0.1:6379> set hello world
OK
127.0.0.1:6379> expire hello 10
(integer) 1
#还剩7秒
127.0.0.1:6379> ttl hello
(integer) 7
...
#还剩0秒
127.0.0.1:6379> ttl hello
(integer) 0
#返回结果为-2，说明键hello已经被删除
127.0.0.1:6379> ttl hello
(integer) -2
```

**ttl 和 pttl**

ttl命令和pttl都可以查询键的剩余过期时间，但是pttl精度更高可以达到毫秒级别，有3种返回值

* 大于等于0的整数，键剩余的过期时间（ttl是秒，pttl是毫秒）

* -1，键没有设置过期时间

* -2，键不存在

```
expireat key timestamp
```

键在秒级时间戳timestamp后过期

**expireat命令**可以设置键的秒级过期时间戳

例如如果需要将键hello在2016-08-0100：00：00（秒级时间戳为1469980800）过期，可以执行如下操作：

```
127.0.0.1:6379> expireat hello 1469980800
(integer) 1
```

除此之外，Redis2.6版本后提供了毫秒级的过期方案：

* pexpire key milliseconds：键在milliseconds毫秒后过期。

* pexpireat key milliseconds-timestamp，键在毫秒级时间戳timestamp后过期。

但无论是使用过期时间还是时间戳，秒级还是毫秒级，在Redis内部最终使用的都是pexpireat。

**注意事项**

如果expire key的键不存在，返回结果为0

```
127.0.0.1:6379> expire not_exist_key 30
(integer) 0
```

如果过期时间为负值，键会立即被删除，犹如使用del命令一样：

```
127.0.0.1:6379> set hello world
OK
127.0.0.1:6379> expire hello -2
(integer) 1
127.0.0.1:6379> get hello
(nil)
```

persist命令可以将键的过期时间清除：

```
127.0.0.1:6379> hset key f1 v1
(integer) 1
127.0.0.1:6379> expire key 50
(integer) 1
127.0.0.1:6379> ttl key
(integer) 46
127.0.0.1:6379> persist key
(integer) 1
127.0.0.1:6379> ttl key
(integer) -1
```

对于字符串类型键，执行set命令会去掉过期时间，这个问题很容易被忽视。

Redis不支持二级数据结构（例如哈希、列表）内部元素的过期功能

如不能对列表类型的一个元素做过期时间设置。

**setex命令**作为set+expire的组合，不但是原子执行，同时减少了一次网络通讯的时间。

# 迁移键

迁移键功能非常重要，因为有时候我们只想把部分数据由一个Redis迁移到另一个Redis（例如从生产环境迁移到测试环境）

Redis发展历程中提供了move、dump+restore、migrate三组迁移键的方法，它们的实现方式以及使用的场景不太相同

```
move：move key db
```

Redis内部可以有多个数据库，彼此在数据上是相互隔离的，move key db就是把指定的键从源数据库移动到目标数据库中，多数据库功能不建议在生产环境使用，所以这个命令知道即可。

```
dump+restore：dump keyrestore key ttl value
```

可以实现在不同的Redis实例之间进行数据迁移的功能，整个迁移的过程分为两步：

* 在源Redis上，dump命令会将键值序列化，格式采用的是RDB格式。

* 在目标Redis上，restore命令将上面序列化的值进行复原，其中ttl参数代表过期时间，如果ttl=0代表没有过期时间。

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210505230228.png" style="zoom:50%;" />

**有两点需要注意：**

* 整个迁移过程并非原子性的，而是通过客户端分步完成的

* 迁移过程是开启了两个客户端连接，所以dump的结果不是在源Redis和目标Redis之间进行传输，

**下面用一个例子演示完整过程**

在源Redis上执行dump：

```
redis-source> set hello world
OK
redis-source> dump hello
"\x00\x05world\x06\x00\x8f<T\x04%\xfcNQ"
```

在目标Redis上执行restore：

```
redis-target> get hello
(nil)
redis-target> restore hello 0 "\x00\x05world\x06\x00\x8f<T\x04%\xfcNQ"
OK
redis-target> get hello
"world"
```

上面2步对应的伪代码如下：

```java
Redis sourceRedis = new Redis("sourceMachine", 6379);
Redis targetRedis = new Redis("targetMachine", 6379);
targetRedis.restore("hello", 0, sourceRedis.dump(key));
```

**migrate**

```
migrate host port key|"" destination-db timeout [copy] [replace] [keys key [key ..
```

用在Redis实例间进行数据迁移的，实际上migrate命令就是将dump、restore、del三个命令进行组合，从而简化了操作流程。

migrate命令具有原子性，而且从Redis3.0.6版本以后已经支持迁移多个键的功能，有效地提高了迁移效率，migrate在水平扩容中起到重要作用。

整个过程如图所示，实现过程和dump+restore基本类似，但是有3点不太相同：

* 第一，整个过程是原子执行的，不需要在多个Redis实例上开启客户端的，只需要在源Redis上执行migrate命令即可。

* 第二，migrate命令的数据传输直接在源Redis和目标Redis上完成的。

* 第三，目标Redis完成restore后会发送OK给源Redis，源Redis接收后会根据migrate对应的选项来决定是否在源Redis上删除对应的键。

**Redis3.0.6版本以后迁移多个键的功能：**

源Redis批量添加多个键

```
127.0.0.1:6379> mset key1 value1 key2 value2 key3 value3
OK
```

源Redis执行如下命令完成多个键的迁移：

```
127.0.0.1:6379> migrate 127.0.0.1 6380 "" 0 5000 keys key1 key2 key3
OK
```

**move、dump+restore、migrate三个命令比较**

![](https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210505230902.png)